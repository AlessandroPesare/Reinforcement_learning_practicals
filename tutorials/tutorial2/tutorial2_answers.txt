Question 1:
dp/banach â€“ Formulate Banach fixed-point theorem.
Formulate the Banach fixed-point theorem after defining all relevant terms.


Definition:
Metric Space: A set ğ‘‹ together with a metric ğ‘‘, which defines the distance between any two points in ğ‘‹.
Definition:
Contraction Mapping: A function ğ‘‡: ğ‘‹ â†’ ğ‘‹ is called a contraction if there exists a constant 0 â‰¤ ğ›¼ < 1 such that for all ğ‘¥, ğ‘¦ in ğ‘‹,
ğ‘‘(ğ‘‡(ğ‘¥), ğ‘‡(ğ‘¦)) â‰¤ ğ›¼ Â· ğ‘‘(ğ‘¥, ğ‘¦).

Theorem Statement:
Once the definitions are clear, you can state the Banach Fixed-Point Theorem:
If ğ‘‹ is a complete metric space and ğ‘‡: ğ‘‹ â†’ ğ‘‹ is a contraction mapping,
then ğ‘‡ has a unique fixed point ğ‘¥ in ğ‘‹, and for any ğ‘¥â‚€ in ğ‘‹, the iterative sequence
defined by ğ‘¥â‚–â‚Šâ‚ = ğ‘‡(ğ‘¥â‚–) converges to ğ‘¥*.
----------------------------------------------------------------------------------------------------------------
Question 2:
dp/banach/proof â€“ Prove Banach fixed-point theorem. Prove the Banach fixed-point theorem.

Theorem (Banach Fixed-Point Theorem):
Let (X,d) be a complete metric space and let T:Xâ†’X be a contraction mapping; that is,
there exists a constant Î± with 0â‰¤Î±<1 such that for every pair
x,y âˆˆ X d(T(x),T(y)) â‰¤ Î±d(x,y).
Then: T has a unique fixed point x*âˆˆX (i.e.,T(x*)=x*).
For any initial point x0âˆˆX the sequence defined by
xn+1=T(xn) converges to x*

Step 1. Constructing the Sequence
Let x0 be an arbitrary point in X. Define a sequence {xn} recursively by
xn+1=T(xn) for nâ‰¥0.
Step 2. Estimating the Distance Between Successive Terms
We first show that the distance between successive terms in the sequence decreases in a controlled way.
By the contraction property of T, for any nâ‰¥0 we have:
d(xn+1,xn)=d(T(xn),T(xnâˆ’1))â‰¤Î±d(xn,xnâˆ’1).
This inequality can be applied recursively.
For n=1, we have:
d(x1,x0)=d(T(x0),x0) (initial distance).
For n=2:
d(x2,x1)â‰¤Î±d(x1,x0).
For n=3:
d(x3,x2)â‰¤Î± d(x2,x1)â‰¤Î±^2 d(x1,x0).
By induction, it follows that for all nâ‰¥1:
d(xn+1,xn)â‰¤Î±^n d(x1,x0).
Step 3. Showing the Sequence is Cauchy. To show that the sequence {xn} converges in the
complete metric space X, we demonstrate that it is a Cauchy sequence.
Let m>n be arbitrary. By the triangle inequality:
d(xm,xn)â‰¤d(xm,xmâˆ’1)+d(xmâˆ’1,xmâˆ’2)+â‹¯+d(xn+1,xn).
Using our previous estimate, we have:
d(xm,xn) â‰¤ âˆ‘ d(xk+1,xk )â‰¤ âˆ‘ Î±^k d(x1 ,x0).
           k=n...mâˆ’1     k=n...mâˆ’1
This sum is a finite portion of a geometric series. Recall that the sum of a geometric series from
k=n to infinity is: âˆ‘ Î±^k = Î±^n/1âˆ’Î±
                    k=n...âˆ
Thus, we have:
d(xm,xn)â‰¤d(x1,x0) âˆ‘Î±^k   â‰¤ d(x1,x0)â‹… Î±^n/1âˆ’Î±
                  k=n..mâˆ’1
Since 0â‰¤ Î± <1 as nâ†’âˆ Î±^n â†’ 0
Therefore, for every Îµ > 0, there exists an N such that for all nâ‰¥N and for all m>n,
d(xm,xn)<Îµ.
This shows that {xn} is a Cauchy sequence.

Step 4. Convergence Using Completeness
Because X is a complete metric space, every Cauchy sequence in X converges to a limit that is also in X.
Let: x*= lim xn
         nâ†’âˆ

Step 5. Showing x* is a Fixed Point
Now, we must show that x* is indeed a fixed point of T.
Since T is a contraction mapping (and hence Lipschitz continuous), we can take limits on both sides of the recursive definition:
xn+1=T(xn).
Taking the limit as nâ†’âˆ on both sides, we have:
lim xn+1 = limT(xn)
nâ†’âˆ        nâ†’âˆ
Using the continuity of T, we can pass the limit inside the function:
x*= T(lim(xn)) = T(x*)
      nâ†’âˆ
Thus, x* is a fixed point of T.

Step 6. Uniqueness of the Fixed Point
Finally, we show that the fixed point x* is unique. Suppose there is another fixed point y*âˆˆX such that:
T(y*)=y*.
Then, using the contraction property:
d(x*,y*)=d(T(x*),T(y*))â‰¤ Î± d(x*,y*).
Since Î±<1 the only way this inequality can hold is if:
d(x*,y*)=0.
Thus, x*=y*, proving the uniqueness of the fixed point.

Conclusion
We have demonstrated that:
The iterative sequence xn+1=T(xn) is Cauchy and converges to a limit x* in X (by the completeness of X).
The limit x* is a fixed point of T (since T is continuous as a contraction mapping).
The fixed point is unique (as any two fixed points must be at zero distance from each other).
This completes the proof of the Banach Fixed-Point Theorem.
----------------------------------------------------------------------------------------------------------------
Question 3:
dp/update/q â€“ Update rule for ğ‘ğœ‹.
Using the Bellman equation for ğ‘ğœ‹ (see Exercise mdp/bellman/qpi), find an update rule
for the approximation ğ‘ğ‘˜+1 of ğ‘ğœ‹ (in terms of ğ‘ğ‘˜, ğœ‹, and ğ‘) analogous to the update rule for ğ‘£ğ‘˜+1.

We start from the Bellman equation for the actionâ€value function qÏ€, which is given by:
qÏ€(s,a)= âˆ‘ p(sâ€²,râˆ£s,a)[r+Î³ âˆ‘ Ï€(aâ€²âˆ£sâ€²)qÏ€(sâ€²,aâ€²)]
         sâ€²,r              aâ€²

Analogously to the update rule for vÏ€, we can define an iterative approximation
qk to qÏ€ by:
qk+1(s,a)= âˆ‘ p(sâ€²,râˆ£s,a)[r+Î³ âˆ‘ Ï€(aâ€²âˆ£sâ€²)qk(sâ€²,aâ€²)]
         sâ€²,r              aâ€²

This update rule uses the current estimate qk to compute the next estimate
qk+1 and thereby converges to qÏ€ under appropriate conditions.
----------------------------------------------------------------------------------------------------------------
Question 4:
gw/simple â€“ Simple 4 Ã— 4 grid world (programming).
Implement a 4Ã—4 grid world with two terminal states in the upper left corner and lower right corners
(resulting in 14 non-terminal states). The four actions ğ’œ = {up, down, left, right} act deterministically,
the discount factor is ğ›¾ = 1, and the reward is always equal to âˆ’1.
Ensure that a maximum number of time steps can be specified.

See the code
----------------------------------------------------------------------------------------------------------------
Question 5:
dp/policy/eval â€“ Iterative policy evaluation (programming). Implement iterative policy evaluation
and use it to estimate ğ‘£ğœ‹ for the grid world in Exercise gw/simple, where ğœ‹ is the equiprobable random policy.

See the code
----------------------------------------------------------------------------------------------------------------
Question 6:
dp/policy/iter â€“ Policy iteration (programming).
Implement policy iteration and use it to estimate ğœ‹âˆ— for the grid world in Exercise gw/simple.
----------------------------------------------------------------------------------------------------------------
Question 7:
dp/value/iter â€“ Value iteration (programming).
Implement value iteration and use it to estimate ğœ‹âˆ— for the grid world in Exercise gw/simple.